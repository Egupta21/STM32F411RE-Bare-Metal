/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

#define RCC_BASE_ADDRESS		0x40023800UL
#define RCC_CFGR_REG_OFFSET		0x08
#define RCC_CFGR_REG_BASE		(RCC_BASE_ADDRESS + RCC_CFGR_REG_OFFSET)

#define AHB1_BASE_ADDRESS		0x40020000UL
#define GPIOA_BASE_ADDRESS		0x40020000UL
int main(void)
{
	// switch HSE as system clock and measure it

	// enable hse bypass bit, since nucleo board doesn't have hse
	uint32_t *pRCC_CR_Base = (uint32_t*) (RCC_BASE_ADDRESS + 0x0);
	*pRCC_CR_Base |= (0x1 << 18);

	// 1. enable hse clock
	*pRCC_CR_Base |= (0x1 << 16);

	// wait for hse clock from external crystal stabalizers
	//while (!(RCC_CR & (1 << 17))) {}

	//switch the system clock to hse
	uint32_t *pRCC_CFRG_Base = (uint32_t*) RCC_CFGR_REG_BASE;
	*pRCC_CFRG_Base |= (0x1 << 0);

	// SET UP MCO1 to measure output signal //

	// step 1. switch mco1 to hse
	*pRCC_CFRG_Base |= (0x2 << 21);

	// step 2. enable GPIOA clock to configure it
	// always use rcc to enable clocks
	uint32_t *pRCC_AHB1_base = (uint32_t*) (RCC_BASE_ADDRESS + 0x30);
	*pRCC_AHB1_base &= ~(0x3 << 0); // clears bits 0 and 1
	*pRCC_AHB1_base |= (0x1 << 0);  // sets bit 0

	// step 3. configure gpioA to be used as a alternate function (because pa8 is gpioa and we want to use pa8 as an output for the clock measurement)
	uint32_t *pGPIOA_base = (uint32_t*) (GPIOA_BASE_ADDRESS + 0x0);
	*pGPIOA_base &= ~(0x3 << 16); // clears bits 16 and 17
	*pGPIOA_base |= (0x2 << 16); // sets bit 17

	// step 4. set GPIOA alternative function to AF0 (this is based on the alternate table mapping chart that shows that MCO1 for PA8 is AF0)
	uint32_t *pGPIOA_afrh = (uint32_t*) (GPIOA_BASE_ADDRESS + 0x24);
	*pGPIOA_afrh &= ~(0xf << 0);
	*pGPIOA_afrh |= (0x0 << 0);







	//



    /* Loop forever */
	for(;;);
}
