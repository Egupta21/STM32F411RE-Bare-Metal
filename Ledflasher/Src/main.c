/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdbool.h>

#define RCC_BASE_ADDRESS		0x40023800UL
#define AHB1_BASE_ADDRESS		0x40020000UL
#define GPIOA_BASE_ADDRESS		0x40020000UL
#define GPIOC_BASE_ADDRESS		0x40020800UL

void delay(volatile uint32_t count)
{
	for (uint32_t i = 0; i < count * 100000; ++i)
	__asm__("nop");
}

int main(void)
{
	/*// pointing to address of enable register for ahb1
	uint32_t *pahb1_enr = (uint32_t*) (RCC_BASE_ADDRESS + 0x30);
	*pahb1_enr |= (0x1 << 0); // enabling gpioa clock by setting bit 0
	*pahb1_enr |= (0x1 << 2); // enabling gpioc clock by setting bit 2

	// pointing to address of gpioa mode
	uint32_t *pgpioa_mode = (uint32_t*) (GPIOA_BASE_ADDRESS + 0x0);
	*pgpioa_mode &= ~(0x3 << 10); // clearing mode of pa5
	*pgpioa_mode |= (0x1 << 10); // setting pa5 to output

	uint32_t *pgpioc_mode = (uint32_t*) (GPIOC_BASE_ADDRESS + 0x0);
	*pgpioc_mode &= ~(0x3 << 26); // clearing mode of pc13
	*pgpioc_mode |= (0x0 << 26); // setting pc13 to input

	// pointing to address of gpioa output type
	uint32_t *pgpioa_otype_reg = (uint32_t*) (GPIOA_BASE_ADDRESS + 0x04);
	*pgpioa_otype_reg &= ~(0x1 << 5); // clearing output type of pa5
	*pgpioa_otype_reg |= (0x0 << 5); // setting output type of pa5 to push-pull

	// pointing to gpio a odr register (used to set push and pull)
	uint32_t *pgpioa_odr_reg = (uint32_t*) (GPIOA_BASE_ADDRESS + 0x14);
	uint32_t *pgpioc_idr_reg = (uint32_t*) (GPIOC_BASE_ADDRESS + 0X10);

	bool ledisON = false; // flag identifying next state of led, if false then led is off and make it glow then set flag to true, if flag is true then set led to off and make flag false
	uint32_t prevInput = 0x1; // value of previous reading on pc13, defaulted to 0x1 because pc13 is high when button is not pressed
	while(1)
	{
		uint32_t currInput = (*pgpioc_idr_reg & (1 << 13)) >> 13; // reads current input of pa13. get value of idr reg and check 13th bit for pa13 input information
		if(currInput == 0 && prevInput == 1) // if the current input is 0 (hence button is pressed) and the previous input was 1 (hence button was not pressed, useful for avoiding issues when button is pressed for long periods, debouncing)
		{
			if(ledisON == false) // if led is not on
			{
				*pgpioa_odr_reg |= (0x1 << 5); // set odr reg for gpio5 to push, turning on led
				ledisON = true;	// update flag
			}
			else
			{
				*pgpioa_odr_reg &= ~(0x1 << 5); // set odr reg for gpio5 to pull
				ledisON = false; // update flag
			}
		}
		prevInput = currInput; // update prev to current, so now if button is pressed for long time then prev and current will both be 0, and so the led doesn't endlessly toggle
	}*/

	GPIO_Handle_t* GPIOD_Handle = GPIOD;
	GPIO_PinConfig_t GPIOD_Config;
}
