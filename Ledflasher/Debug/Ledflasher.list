
Ledflasher.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000198  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000001e0  08000198  08000198  00001198  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000000  08000378  08000380  00001380  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .ARM.extab    00000000  08000378  08000378  00001380  2**0
                  CONTENTS, READONLY
  4 .ARM          00000000  08000378  08000378  00001380  2**0
                  CONTENTS, READONLY
  5 .preinit_array 00000000  08000378  08000380  00001380  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08000378  08000378  00001378  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  0800037c  0800037c  0000137c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000000  20000000  20000000  00001380  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          0000001c  20000000  08000380  00002000  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  2000001c  08000380  0000201c  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  00001380  2**0
                  CONTENTS, READONLY
 12 .debug_info   000001a7  00000000  00000000  000013b0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 000000e2  00000000  00000000  00001557  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_aranges 00000050  00000000  00000000  00001640  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_rnglists 00000033  00000000  00000000  00001690  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  00000fd7  00000000  00000000  000016c3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_line   00000523  00000000  00000000  0000269a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_str    00003dbf  00000000  00000000  00002bbd  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .comment      00000043  00000000  00000000  0000697c  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00000080  00000000  00000000  000069c0  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 21 .debug_line_str 00000053  00000000  00000000  00006a40  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000198 <__do_global_dtors_aux>:
 8000198:	b510      	push	{r4, lr}
 800019a:	4c05      	ldr	r4, [pc, #20]	@ (80001b0 <__do_global_dtors_aux+0x18>)
 800019c:	7823      	ldrb	r3, [r4, #0]
 800019e:	b933      	cbnz	r3, 80001ae <__do_global_dtors_aux+0x16>
 80001a0:	4b04      	ldr	r3, [pc, #16]	@ (80001b4 <__do_global_dtors_aux+0x1c>)
 80001a2:	b113      	cbz	r3, 80001aa <__do_global_dtors_aux+0x12>
 80001a4:	4804      	ldr	r0, [pc, #16]	@ (80001b8 <__do_global_dtors_aux+0x20>)
 80001a6:	f3af 8000 	nop.w
 80001aa:	2301      	movs	r3, #1
 80001ac:	7023      	strb	r3, [r4, #0]
 80001ae:	bd10      	pop	{r4, pc}
 80001b0:	20000000 	.word	0x20000000
 80001b4:	00000000 	.word	0x00000000
 80001b8:	08000360 	.word	0x08000360

080001bc <frame_dummy>:
 80001bc:	b508      	push	{r3, lr}
 80001be:	4b03      	ldr	r3, [pc, #12]	@ (80001cc <frame_dummy+0x10>)
 80001c0:	b11b      	cbz	r3, 80001ca <frame_dummy+0xe>
 80001c2:	4903      	ldr	r1, [pc, #12]	@ (80001d0 <frame_dummy+0x14>)
 80001c4:	4803      	ldr	r0, [pc, #12]	@ (80001d4 <frame_dummy+0x18>)
 80001c6:	f3af 8000 	nop.w
 80001ca:	bd08      	pop	{r3, pc}
 80001cc:	00000000 	.word	0x00000000
 80001d0:	20000004 	.word	0x20000004
 80001d4:	08000360 	.word	0x08000360

080001d8 <main>:
	for (uint32_t i = 0; i < count * 100000; ++i)
	__asm__("nop");
}

int main(void)
{
 80001d8:	b480      	push	{r7}
 80001da:	b08b      	sub	sp, #44	@ 0x2c
 80001dc:	af00      	add	r7, sp, #0
	// pointing to address of enable register for ahb1
	uint32_t *pahb1_enr = (uint32_t*) (RCC_BASE_ADDRESS + 0x30);
 80001de:	4b33      	ldr	r3, [pc, #204]	@ (80002ac <main+0xd4>)
 80001e0:	61fb      	str	r3, [r7, #28]
	*pahb1_enr |= (0x1 << 0); // enabling gpioa clock by setting bit 0
 80001e2:	69fb      	ldr	r3, [r7, #28]
 80001e4:	681b      	ldr	r3, [r3, #0]
 80001e6:	f043 0201 	orr.w	r2, r3, #1
 80001ea:	69fb      	ldr	r3, [r7, #28]
 80001ec:	601a      	str	r2, [r3, #0]
	*pahb1_enr |= (0x1 << 2); // enabling gpioc clock by setting bit 2
 80001ee:	69fb      	ldr	r3, [r7, #28]
 80001f0:	681b      	ldr	r3, [r3, #0]
 80001f2:	f043 0204 	orr.w	r2, r3, #4
 80001f6:	69fb      	ldr	r3, [r7, #28]
 80001f8:	601a      	str	r2, [r3, #0]

	// pointing to address of gpioa mode
	uint32_t *pgpioa_mode = (uint32_t*) (GPIOA_BASE_ADDRESS + 0x0);
 80001fa:	4b2d      	ldr	r3, [pc, #180]	@ (80002b0 <main+0xd8>)
 80001fc:	61bb      	str	r3, [r7, #24]
	*pgpioa_mode &= ~(0x3 << 10); // clearing mode of pa5
 80001fe:	69bb      	ldr	r3, [r7, #24]
 8000200:	681b      	ldr	r3, [r3, #0]
 8000202:	f423 6240 	bic.w	r2, r3, #3072	@ 0xc00
 8000206:	69bb      	ldr	r3, [r7, #24]
 8000208:	601a      	str	r2, [r3, #0]
	*pgpioa_mode |= (0x1 << 10); // setting pa5 to output
 800020a:	69bb      	ldr	r3, [r7, #24]
 800020c:	681b      	ldr	r3, [r3, #0]
 800020e:	f443 6280 	orr.w	r2, r3, #1024	@ 0x400
 8000212:	69bb      	ldr	r3, [r7, #24]
 8000214:	601a      	str	r2, [r3, #0]

	uint32_t *pgpioc_mode = (uint32_t*) (GPIOC_BASE_ADDRESS + 0x0);
 8000216:	4b27      	ldr	r3, [pc, #156]	@ (80002b4 <main+0xdc>)
 8000218:	617b      	str	r3, [r7, #20]
	*pgpioc_mode &= ~(0x3 << 26); // clearing mode of pc13
 800021a:	697b      	ldr	r3, [r7, #20]
 800021c:	681b      	ldr	r3, [r3, #0]
 800021e:	f023 6240 	bic.w	r2, r3, #201326592	@ 0xc000000
 8000222:	697b      	ldr	r3, [r7, #20]
 8000224:	601a      	str	r2, [r3, #0]
	*pgpioc_mode |= (0x0 << 26); // setting pc13 to input
 8000226:	697b      	ldr	r3, [r7, #20]
 8000228:	681a      	ldr	r2, [r3, #0]
 800022a:	697b      	ldr	r3, [r7, #20]
 800022c:	601a      	str	r2, [r3, #0]

	// pointing to address of gpioa output type
	uint32_t *pgpioa_otype_reg = (uint32_t*) (GPIOA_BASE_ADDRESS + 0x04);
 800022e:	4b22      	ldr	r3, [pc, #136]	@ (80002b8 <main+0xe0>)
 8000230:	613b      	str	r3, [r7, #16]
	*pgpioa_otype_reg &= ~(0x1 << 5); // clearing output type of pa5
 8000232:	693b      	ldr	r3, [r7, #16]
 8000234:	681b      	ldr	r3, [r3, #0]
 8000236:	f023 0220 	bic.w	r2, r3, #32
 800023a:	693b      	ldr	r3, [r7, #16]
 800023c:	601a      	str	r2, [r3, #0]
	*pgpioa_otype_reg |= (0x0 << 5); // setting output type of pa5 to push-pull
 800023e:	693b      	ldr	r3, [r7, #16]
 8000240:	681a      	ldr	r2, [r3, #0]
 8000242:	693b      	ldr	r3, [r7, #16]
 8000244:	601a      	str	r2, [r3, #0]

	// pointing to gpio a odr register (used to set push and pull)
	uint32_t *pgpioa_odr_reg = (uint32_t*) (GPIOA_BASE_ADDRESS + 0x14);
 8000246:	4b1d      	ldr	r3, [pc, #116]	@ (80002bc <main+0xe4>)
 8000248:	60fb      	str	r3, [r7, #12]
	uint32_t *pgpioc_idr_reg = (uint32_t*) (GPIOC_BASE_ADDRESS + 0X10);
 800024a:	4b1d      	ldr	r3, [pc, #116]	@ (80002c0 <main+0xe8>)
 800024c:	60bb      	str	r3, [r7, #8]

	bool ledisON = false; // flag identifying next state of led, if false then led is off and make it glow then set flag to true, if flag is true then set led to off and make flag false
 800024e:	2300      	movs	r3, #0
 8000250:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
	uint32_t prevInput = 0x1; // value of previous reading on pc13, defaulted to 0x1 because pc13 is high when button is not pressed
 8000254:	2301      	movs	r3, #1
 8000256:	623b      	str	r3, [r7, #32]
	while(1)
	{
		uint32_t currInput = (*pgpioc_idr_reg & (1 << 13)) >> 13; // reads current input of pa13. get value of idr reg and check 13th bit for pa13 input information
 8000258:	68bb      	ldr	r3, [r7, #8]
 800025a:	681b      	ldr	r3, [r3, #0]
 800025c:	0b5b      	lsrs	r3, r3, #13
 800025e:	f003 0301 	and.w	r3, r3, #1
 8000262:	607b      	str	r3, [r7, #4]
		if(currInput == 0 && prevInput == 1) // if the current input is 0 (hence button is pressed) and the previous input was 1 (hence button was not pressed, useful for avoiding issues when button is pressed for long periods, debouncing)
 8000264:	687b      	ldr	r3, [r7, #4]
 8000266:	2b00      	cmp	r3, #0
 8000268:	d11c      	bne.n	80002a4 <main+0xcc>
 800026a:	6a3b      	ldr	r3, [r7, #32]
 800026c:	2b01      	cmp	r3, #1
 800026e:	d119      	bne.n	80002a4 <main+0xcc>
		{
			if(ledisON == false) // if led is not on
 8000270:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
 8000274:	f083 0301 	eor.w	r3, r3, #1
 8000278:	b2db      	uxtb	r3, r3
 800027a:	2b00      	cmp	r3, #0
 800027c:	d009      	beq.n	8000292 <main+0xba>
			{
				*pgpioa_odr_reg |= (0x1 << 5); // set odr reg for gpio5 to push, turning on led
 800027e:	68fb      	ldr	r3, [r7, #12]
 8000280:	681b      	ldr	r3, [r3, #0]
 8000282:	f043 0220 	orr.w	r2, r3, #32
 8000286:	68fb      	ldr	r3, [r7, #12]
 8000288:	601a      	str	r2, [r3, #0]
				ledisON = true;	// update flag
 800028a:	2301      	movs	r3, #1
 800028c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
 8000290:	e008      	b.n	80002a4 <main+0xcc>
			}
			else
			{
				*pgpioa_odr_reg &= ~(0x1 << 5); // set odr reg for gpio5 to pull
 8000292:	68fb      	ldr	r3, [r7, #12]
 8000294:	681b      	ldr	r3, [r3, #0]
 8000296:	f023 0220 	bic.w	r2, r3, #32
 800029a:	68fb      	ldr	r3, [r7, #12]
 800029c:	601a      	str	r2, [r3, #0]
				ledisON = false; // update flag
 800029e:	2300      	movs	r3, #0
 80002a0:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
			}
		}
		prevInput = currInput; // update prev to current, so now if button is pressed for long time then prev and current will both be 0, and so the led doesn't endlessly toggle
 80002a4:	687b      	ldr	r3, [r7, #4]
 80002a6:	623b      	str	r3, [r7, #32]
	{
 80002a8:	e7d6      	b.n	8000258 <main+0x80>
 80002aa:	bf00      	nop
 80002ac:	40023830 	.word	0x40023830
 80002b0:	40020000 	.word	0x40020000
 80002b4:	40020800 	.word	0x40020800
 80002b8:	40020004 	.word	0x40020004
 80002bc:	40020014 	.word	0x40020014
 80002c0:	40020810 	.word	0x40020810

080002c4 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 80002c4:	480d      	ldr	r0, [pc, #52]	@ (80002fc <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 80002c6:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 80002c8:	f3af 8000 	nop.w

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 80002cc:	480c      	ldr	r0, [pc, #48]	@ (8000300 <LoopForever+0x6>)
  ldr r1, =_edata
 80002ce:	490d      	ldr	r1, [pc, #52]	@ (8000304 <LoopForever+0xa>)
  ldr r2, =_sidata
 80002d0:	4a0d      	ldr	r2, [pc, #52]	@ (8000308 <LoopForever+0xe>)
  movs r3, #0
 80002d2:	2300      	movs	r3, #0
  b LoopCopyDataInit
 80002d4:	e002      	b.n	80002dc <LoopCopyDataInit>

080002d6 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80002d6:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80002d8:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80002da:	3304      	adds	r3, #4

080002dc <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80002dc:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80002de:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80002e0:	d3f9      	bcc.n	80002d6 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80002e2:	4a0a      	ldr	r2, [pc, #40]	@ (800030c <LoopForever+0x12>)
  ldr r4, =_ebss
 80002e4:	4c0a      	ldr	r4, [pc, #40]	@ (8000310 <LoopForever+0x16>)
  movs r3, #0
 80002e6:	2300      	movs	r3, #0
  b LoopFillZerobss
 80002e8:	e001      	b.n	80002ee <LoopFillZerobss>

080002ea <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 80002ea:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 80002ec:	3204      	adds	r2, #4

080002ee <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 80002ee:	42a2      	cmp	r2, r4
  bcc FillZerobss
 80002f0:	d3fb      	bcc.n	80002ea <FillZerobss>

/* Call static constructors */
  bl __libc_init_array
 80002f2:	f000 f811 	bl	8000318 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 80002f6:	f7ff ff6f 	bl	80001d8 <main>

080002fa <LoopForever>:

LoopForever:
  b LoopForever
 80002fa:	e7fe      	b.n	80002fa <LoopForever>
  ldr   r0, =_estack
 80002fc:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 8000300:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8000304:	20000000 	.word	0x20000000
  ldr r2, =_sidata
 8000308:	08000380 	.word	0x08000380
  ldr r2, =_sbss
 800030c:	20000000 	.word	0x20000000
  ldr r4, =_ebss
 8000310:	2000001c 	.word	0x2000001c

08000314 <ADC_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8000314:	e7fe      	b.n	8000314 <ADC_IRQHandler>
	...

08000318 <__libc_init_array>:
 8000318:	b570      	push	{r4, r5, r6, lr}
 800031a:	4d0d      	ldr	r5, [pc, #52]	@ (8000350 <__libc_init_array+0x38>)
 800031c:	4c0d      	ldr	r4, [pc, #52]	@ (8000354 <__libc_init_array+0x3c>)
 800031e:	1b64      	subs	r4, r4, r5
 8000320:	10a4      	asrs	r4, r4, #2
 8000322:	2600      	movs	r6, #0
 8000324:	42a6      	cmp	r6, r4
 8000326:	d109      	bne.n	800033c <__libc_init_array+0x24>
 8000328:	4d0b      	ldr	r5, [pc, #44]	@ (8000358 <__libc_init_array+0x40>)
 800032a:	4c0c      	ldr	r4, [pc, #48]	@ (800035c <__libc_init_array+0x44>)
 800032c:	f000 f818 	bl	8000360 <_init>
 8000330:	1b64      	subs	r4, r4, r5
 8000332:	10a4      	asrs	r4, r4, #2
 8000334:	2600      	movs	r6, #0
 8000336:	42a6      	cmp	r6, r4
 8000338:	d105      	bne.n	8000346 <__libc_init_array+0x2e>
 800033a:	bd70      	pop	{r4, r5, r6, pc}
 800033c:	f855 3b04 	ldr.w	r3, [r5], #4
 8000340:	4798      	blx	r3
 8000342:	3601      	adds	r6, #1
 8000344:	e7ee      	b.n	8000324 <__libc_init_array+0xc>
 8000346:	f855 3b04 	ldr.w	r3, [r5], #4
 800034a:	4798      	blx	r3
 800034c:	3601      	adds	r6, #1
 800034e:	e7f2      	b.n	8000336 <__libc_init_array+0x1e>
 8000350:	08000378 	.word	0x08000378
 8000354:	08000378 	.word	0x08000378
 8000358:	08000378 	.word	0x08000378
 800035c:	0800037c 	.word	0x0800037c

08000360 <_init>:
 8000360:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000362:	bf00      	nop
 8000364:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8000366:	bc08      	pop	{r3}
 8000368:	469e      	mov	lr, r3
 800036a:	4770      	bx	lr

0800036c <_fini>:
 800036c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800036e:	bf00      	nop
 8000370:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8000372:	bc08      	pop	{r3}
 8000374:	469e      	mov	lr, r3
 8000376:	4770      	bx	lr
